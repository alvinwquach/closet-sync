// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init
// Generator for Prisma Client
generator client {
  provider = "prisma-client-js" // Generates Prisma Client for database operations
}

// Data source configuration
datasource db {
  provider = "postgresql" // Using PostgreSQL as the database
  url      = env("DATABASE_URL") // Database connection URL from environment variable
}

// Enum Role represents the different user roles in the system
enum Role {
  ADMIN      // Admin user with elevated permissions
  MODERATOR  // Moderator with limited administrative capabilities
  USER       // Regular user with standard access
}

// Enum Condition represents the different conditions a product can be in
enum Condition {
  BRAND_NEW        // Product is brand new
  TRIED_ON        // Product has been tried on but not used
  NEW_WITH_DEFECTS // New product with defects
  NEW_WITH_TAGS    // New product still with tags
  NEW_WITHOUT_TAGS // New product without tags
  USED             // Used product
  IN_BOX          // Product is in its original box
  NO_BOX          // Product is without its box
}

// Enum RaffleType indicates the types of raffles available
enum RaffleType {
  IN_APP      // Raffle can be entered within the app
  ONLINE      // Raffle can be entered online
  IN_STORE    // Raffle can be entered in physical stores
}

// Enum RaffleStatus represents the current status of a raffle
enum RaffleStatus {
  OPEN      // Raffle is currently open for entries
  CLOSED    // Raffle has closed and is no longer accepting entries
  CANCELED  // Raffle has been canceled
}

// Enum TicketStatus indicates the status of a support ticket
enum TicketStatus {
  OPEN             // The ticket has been created and is awaiting attention
  IN_PROGRESS      // The ticket is currently being addressed by support staff
  RESOLVED         // The issue has been resolved, and the ticket is waiting for confirmation
  CLOSED           // The ticket has been officially closed after resolution
}

// Enum FlagStatus represents the status of a product flag
enum ProductFlagStatus {
  REPORTED         // Product has been flagged and is pending review
  UNDER_REVIEW     // Product is currently being reviewed by an admin or moderator
  RESOLVED         // Flag has been reviewed and the issue has been addressed
  IGNORED          // Flag has been reviewed but deemed not a valid issue
  REMOVED          // Product has been removed from the marketplace
}

// Enum ProductFlagReason represents the reasons a product might be flagged
enum ProductFlagReason {
  FAKE                     // Product is counterfeit
  NOT_AS_DESCRIBED         // Product does not match the description provided
  INAPPROPRIATE_CONTENT    // Content is offensive or inappropriate
  SPAM                     // Listing is considered spam
  COPYRIGHT_INFRINGEMENT    // Product violates copyright laws
  IMPERSONATION             // Seller falsely represents a brand
  ALTERED_IMAGES            // Product images have been digitally altered
  COUNTERFEIT_LABELS       // Product displays fake branding
  SUSPICIOUSLY_LOW_PRICE    // Unusually low price raises suspicion
  BAD_REVIEWS              // Multiple negative reviews about authenticity
  UNVERIFIABLE_CLAIMS      // Claims made by the seller are unverifiable
  LACK_OF_AUTHENTICITY     // Seller cannot provide proof of authenticity
  UNAUTHORIZED_RESELLER    // Seller is not an authorized reseller for the brand
  FAKE_REVIEWS             // Product has numerous fabricated reviews
  LIMITED_SUPPLY           // Misleading claims of being in short supply
  EXCESSIVE_RETURNS        // High return rate due to counterfeiting
  DISCONTINUED_MODEL       // Selling of a discontinued model
  MISMATCHED_SERIAL_NUMBERS // Serial numbers do not match expected values
  INCONSISTENT_BRANDING    // Branding or packaging inconsistencies
  LACK_OF_WARRANTY         // No valid warranty provided
  UNRELIABLE_SELLER_HISTORY // Seller has a history of complaints
  REPRODUCTION_LABELS      // Being sold as original when it's a reproduction
  UNAUTHENTIC_MATERIALS    // Made from materials that do not match the description
  UNRELIABLE_SIZE_CHART    // Size chart does not match actual sizing
  INACCURATE_COLOR_REPRESENTATION // Color differs from images shown
  DISREPUTED_BRAND         // Brand has a history of authenticity complaints
  UNAUTHORIZED_CUSTOMIZATION // Customized in a way not sanctioned by the brand
  SEASONALITY_ISSUES      // Sold out of season, raising authenticity suspicions
  MISSING_CERTIFICATION    // Should have certifications but does not provide proof
  BULK_RESALE_SCAM        // Part of a bulk resale scam
  FAKE_OR_MISLEADING_ENDORSEMENTS // Claims endorsements that are not genuine
  COMPROMISED_PACKAGING    // Packaging shows signs of tampering
  OTHER                    // Any other reason not specified
}

// Enum ProductStatus represents the availability of a product
enum ProductStatus {
  ACTIVE           // Product is available for sale
  DEACTIVATED      // Product is temporarily removed from the marketplace but can be reactivated
  BANNED           // Product is permanently banned from the marketplace
}

// Enum RaffleResult indicates the outcome of a raffle entry
enum RaffleResult {
  WON    // User won the raffle
  LOST   // User lost the raffle
  PENDING // Raffle outcome is still pending
}

// Enum ReactionType defines the types of reactions a user can give
enum ReactionType {
  LIKE       // Like reaction
  LOVE       // Love reaction
  WOW        // Wow reaction
  SAD        // Sad reaction
  ANGRY      // Angry reaction
  CHEER      // Cheer reaction
  LAUGH      // Laugh reaction
  SURPRISE   // Surprise reaction
  DISLIKE    // Dislike reaction
  CONFUSED   // Confused reaction
  GRATEFUL   // Grateful reaction
  APPLAUD    // Applaud reaction
}

model User {
  // Unique identifier for each user
  id               Int               @id @default(autoincrement()) 
  // User's email address (must be unique)
  email            String            @unique 
  // User's password (hashed for security)
  password         String            
  // Role of the user (e.g., admin, regular user)
  role             Role              @default(USER) 
  // Unique username for the user
  username         String            @unique 
  // Timestamp for when the user account was created
  createdAt        DateTime          @default(now()) 
  // URL to the user's profile picture (optional)
  profilePicture   String?           
  // Short biography or description of the user (optional)
  bio              String?           
  // User's location (optional)
  location         String?           
  // Timestamp for the user's last activity (optional)
  lastActive       DateTime?         
  // Average rating based on reviews (0 to 100)
  averageRating    Float?            @default(0) 
  // Count of ratings received
  ratingCount      Int?              @default(0) 

  // One user can list many products (One-to-Many)
  products         Product[]         
  // One user can favorite many products (Many-to-Many)
  favorites        Product[]         @relation("Favorites") 
  // One user can view many products (Many-to-Many)
  viewedProducts   Product[]         @relation("ViewedProducts") 
  // One user can have many search history records (One-to-Many)
  searchHistory    SearchHistory[]    
  // One user can enter many raffles (One-to-Many)
  enteredRaffles   RaffleEntry[]      
  // One user can receive many notifications (One-to-Many)
  notifications    Notification[]     
  // One user can give many ratings (One-to-Many)
  ratingsGiven     UserRating[]      @relation("RatingsGiven") 
  // One user can receive many ratings (One-to-Many)
  ratingsReceived  UserRating[]      @relation("RatingsReceived") 
  // One user can send many messages (One-to-Many)
  sentMessages     Message[]         @relation("Sender") 
  // One user can receive many messages (One-to-Many)
  receivedMessages Message[]         @relation("Receiver") 
  // One user can give many reactions to messages (One-to-Many)
  reactions        MessageReaction[]  
  // One user can have a wishlist of many products (One-to-Many)
  wishlist         Wishlist[]        
  // One user can write many reviews (One-to-Many)
  reviews          Review[]          
  // One user can have multiple search filters (One-to-Many)
  searchFilter     SearchFilter[]    
  // One user can save multiple searches (One-to-Many)
  savedSearch      SavedSearch[]     
  // One user can file many reports (One-to-Many)
  report           Report[]          
  // One user can have many activity records (One-to-Many)
  userActivity     UserActivity[]    
  // One user can have multiple preferences (One-to-Many)
  userPreferences  UserPreference[]  
  // One user can make multiple moderation reports (One-to-Many)
  moderationReports ModerationReport[] 
  // One user can have many engagement metrics (One-to-Many)
  engagementMetrics EngagementMetric[] 
  // One user can follow many users (Many-to-Many)
  following        UserFollow[]      @relation("UserFollows") 
  // One user can be followed by many users (Many-to-Many)
  followers        UserFollow[]      @relation("UserFollowedBy") 
  // One user can start many discussion threads (One-to-Many)
  threads          Thread[]          
  // One user can create many posts (One-to-Many)
  posts            Post[]            
  // One user can react to many posts (One-to-Many)
  postReactions    PostReaction[]    @relation("UserPostReactions") 
  // One user can create many polls (One-to-Many)
  polls            Poll[]            
  // One user can cast many votes in polls (One-to-Many)
  pollVotes        PollVote[]        
  // One user can earn many badges (One-to-Many)
  userBadges       UserBadge[]      
  // One user can submit many support tickets (One-to-Many)
  supportTickets   SupportTicket[]   
  // One user can make many comments (One-to-Many)
  comments         Comment[]         
  // One user can give ratings to many products (One-to-Many)
  productRating    ProductRating[]   
  // One user can speak many languages (Many-to-Many)
  language         Language[]        
  // One user can achieve many achievements (One-to-Many)
  userAchievements  UserAchievement[] 
  // One user can have multiple leaderboard entries (One-to-Many)
  leaderboards      Leaderboard[]     
  // One user can make many purchases (One-to-Many)
  purchases        Purchase[]        @relation("UserPurchases") 
  // One user can make many sales (One-to-Many)
  sales            Sale[]            @relation("UserSales") 
  // One user can create many product flags (One-to-Many)
  productFlags     ProductFlag[]     @relation("UserProductFlags") 

  // Unique constraints ensuring username and email are unique
  @@unique([username, email]) 
}

model UserFollow {
  // Unique ID for follow relationship (Primary Key)
  id         Int  @id @default(autoincrement()) 
  // User ID of the follower (Foreign Key)
  followerId Int 
  // User ID of the user being followed (Foreign Key)
  followedId Int 
  // One user can follow many users (Many-to-One)
  follower   User @relation("UserFollows", fields: [followerId], references: [id]) 
  // One user can be followed by many users (Many-to-One)
  followed   User @relation("UserFollowedBy", fields: [followedId], references: [id]) 

  // Ensures unique follower-followed relationship
  @@unique([followerId, followedId]) 
}

model UserRating {
  // Unique ID for rating (Primary Key)
  id      Int  @id @default(autoincrement()) 
  // User ID of the person giving the rating (Foreign Key)
  raterId Int 
  // User ID of the person receiving the rating (Foreign Key)
  ratedId Int 
  // Rating value (e.g., 1-5)
  rating  Int 
  // One user can give many ratings (Many-to-One)
  rater   User @relation("RatingsGiven", fields: [raterId], references: [id]) 
  // One user can receive many ratings (Many-to-One)
  rated   User @relation("RatingsReceived", fields: [ratedId], references: [id]) 

  // Ensures unique rating from one user to another
  @@unique([raterId, ratedId]) 
}

model UserBadge {
  // Unique ID for the user badge entry (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // User ID who earned the badge (Foreign Key)
  userId    Int      
  // Badge ID that this entry relates to (Foreign Key)
  badgeId   Int      
  // Timestamp of when the badge was earned
  createdAt DateTime @default(now()) 
  // One User can earn many UserBadges. (One-to-Many relationship)
  user      User     @relation(fields: [userId], references: [id]) 
  // One Badge can be earned by many UserBadges. (Many-to-One relationship)
  badge     Badge    @relation(fields: [badgeId], references: [id]) 

  // Ensures a user can earn a badge only once
  @@unique([userId, badgeId]) 
}

model UserActivity {
  // Unique ID for activity (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // User ID associated with this activity (Foreign Key)
  userId    Int 
  // Description of the action taken by the user
  action    String 
  // Timestamp of when the action occurred
  createdAt DateTime @default(now()) 
  // Activity is related to one user (Many-to-One relationship)
  user      User     @relation(fields: [userId], references: [id]) 

  // Ensures unique activities for a user at the same timestamp
  @@unique([userId, createdAt]) 
}
 

model Notification {
  // Unique ID for notification (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // User ID to receive this notification (Foreign Key)
  userId    Int 
  // Notification message content
  message   String 
  // Timestamp of when the notification was created
  createdAt DateTime @default(now()) 
  // Indicates if the notification has been read
  read      Boolean  @default(false) 
  // Notification is related to one user (Many-to-One relationship)
  user      User     @relation(fields: [userId], references: [id]) 
}

model Product {
  // Unique identifier for the product (Primary Key)
  id            Int             @id @default(autoincrement()) 
  // Title of the product
  title         String          
  // Description of the product
  description   String         
  // Optional cost of the product
  cost          Float?          
  // Price of the product
  price         Float           
  // Condition of the product (e.g., new, used)
  condition     Condition       
  // Status of the product indicating its availability
  status        ProductStatus    @default(ACTIVE) 
  // Timestamp for when the product was created
  createdAt     DateTime        @default(now()) 
  // Timestamp for when the product was sold (optional)
  soldAt        DateTime?       
  // Release date of the product (optional)
  releaseDate   DateTime?       
  // ID of the seller (Foreign Key)
  sellerId      Int             
  // Indicates if the product has a raffle
  hasRaffle     Boolean          @default(false) 
  // ID of the country (optional, Foreign Key)
  countryId     Int?             
  // ID of the brand (optional, Foreign Key)
  brandId       Int?             
  // One seller can list many products (One-to-Many relationship)
  seller        User             @relation(fields: [sellerId], references: [id]) 
  // Many users can favorite one product (Many-to-Many relationship)
  favoritedBy   User[]           @relation("Favorites") 
  // Many users can view one product (Many-to-Many relationship)
  viewedBy      User[]           @relation("ViewedProducts") 
  // One product can have many historical price records (One-to-Many relationship)
  priceHistory  PriceHistory[]   
  // One product can have many raffles (One-to-Many relationship)
  raffles       Raffle[]      
  // One product can have many media entries (One-to-Many relationship)
  media         Media[]         
  // One product may be linked to one country (Many-to-One, optional relationship)
  country       Country?         @relation(fields: [countryId], references: [id]) 
  // One product may be linked to one brand (Many-to-One, optional relationship)
  brand         Brand?           @relation(fields: [brandId], references: [id]) 
  // One product can have many ratings (One-to-Many relationship)
  ratings       ProductRating[]  
  // One product can have many reports (One-to-Many relationship)
  reports       Report[]        
  // One product can have many comments (One-to-Many relationship)
  comments      Comment[]       
  // One product can be wishlisted by many users (One-to-Many relationship)
  wishlistedBy  Wishlist[]      
  // One product can have many reviews (One-to-Many relationship)
  reviews       Review[]        
  // One product can have many engagement metrics (One-to-Many relationship)
  engagementMetrics EngagementMetric[] 
  // One product can have many tags (Many-to-Many relationship)
  tags          ProductTag[]    
  // One product can have many variants (One-to-Many relationship)
  variants      ProductVariant[] 
  // One product can be included in many bundles (One-to-Many relationship)
  bundles       ProductBundle[]  
  // One product can belong to many categories (Many-to-Many relationship)
  categories    ProductCategory[] 
  // Available quantity of the product
  quantity      Int              
  // Stock level of the product (optional)
  stock         Int?             
  // One product can have many sales (One-to-Many relationship)
  sales         Sale[]           @relation("ProductSales") 
  // One product can be included in many purchases (One-to-Many relationship)
  purchases     Purchase[]       @relation("ProductPurchased") 
  // One product can have many flags (One-to-Many relationship)
  flags         ProductFlag[]     @relation("ProductFlagged") 
}

model Sale {
  // Unique identifier for the sale (Primary Key)
  id         Int      @id @default(autoincrement()) 
  // ID of the product sold (Foreign Key)
  productId  Int     
  // ID of the user making the sale (Foreign Key)
  userId     Int     
  // Quantity sold
  quantity    Int
  // Total price of the sale      
  totalPrice Float     
  // Timestamp of the sale
  soldAt     DateTime @default(now()) 
  // Many sales can refer to one product (Many-to-One relationship)
  product    Product   @relation("ProductSales", fields: [productId], references: [id]) 
  // Many sales can be made by one user (Many-to-One relationship)
  user       User      @relation("UserSales", fields: [userId], references: [id]) 
  // One sale can be linked to multiple purchases (One-to-Many relationship)
  purchases  Purchase[] @relation("SalePurchases")
}

model Purchase {
  // Unique identifier for the purchase (Primary Key)
  id         Int      @id @default(autoincrement()) 
  // ID of the associated sale (Foreign Key)
  saleId     Int      
  // ID of the user making the purchase (Foreign Key)
  userId     Int      
  // ID of the product purchased (Foreign Key)
  productId  Int      
  // Timestamp of the purchase
  createdAt  DateTime @default(now()) 
  // Timestamp of when the item was sold (same as sale time)
  soldAt     DateTime 

  // A purchase is linked to one sale (Many-to-One relationship)
  sale       Sale      @relation("SalePurchases", fields: [saleId], references: [id]) 
  // A purchase is made by one user (Many-to-One relationship)
  user       User      @relation("UserPurchases", fields: [userId], references: [id]) 
  // A purchase is for one product (Many-to-One relationship)
  product    Product   @relation("ProductPurchased", fields: [productId], references: [id]) 
}

model ProductFlag {
  // Unique identifier for the flag (Primary Key)
  id           Int           @id @default(autoincrement())
  // ID of the associated product (Foreign Key)
  productId    Int
  // Reason for flagging the product (e.g., fake)
  reason       ProductFlagReason
  // Status of the flag (e.g., reported, resolved)
  status       ProductFlagStatus    @default(REPORTED)
  // Timestamp of when the flag was created
  createdAt    DateTime      @default(now())
  // ID of the user who created the flag (Foreign Key)
  createdById  Int
  // User who created the flag (Many-to-One relationship)
  createdBy    User          @relation("UserProductFlags", fields: [createdById], references: [id])
  // Product being flagged (Many-to-One relationship)
  product      Product       @relation("ProductFlagged", fields: [productId], references: [id])
  
  // Unique constraint to ensure a user can only flag the same product for the same reason once
  @@unique([productId, reason, createdById]) 
}

model Category {
  // Unique ID for the category (Primary Key)
  id          Int       @id @default(autoincrement()) 
  // The name of the category (e.g., Electronics, Clothing)
  name        String    
  // A brief description of the category, optional
  description String?   
  // Many-to-Many: A category can contain many products
  products    ProductCategory[] 
}

model ProductCategory {
  // Foreign key to Product
  productId   Int 
  // Foreign key to Category
  categoryId  Int 
  // Many-to-One: Product belongs to one Category
  product     Product @relation(fields: [productId], references: [id]) 
  // Many-to-One: Category can contain multiple Products
  category    Category @relation(fields: [categoryId], references: [id]) 

  // Composite primary key
  @@id([productId, categoryId]) 
}

model Country {
  // Unique ID for the country
  id       Int       @id @default(autoincrement()) 
  // Name of the country
  name     String    
  // One-to-Many: A country can have multiple associated products
  products Product[] 
}

model Brand {
  // Unique ID for the brand
  id       Int       @id @default(autoincrement()) 
  // Name of the brand
  name     String    
  // One-to-Many: A brand can have multiple associated products
  products Product[] 
}

model PriceHistory {
  // Unique ID for price history entry
  id        Int      @id @default(autoincrement()) 
  // Associated product ID
  productId Int 
  // Price value
  price     Float 
  // Timestamp of when the price was recorded
  createdAt DateTime @default(now()) 
  // Many-to-One: Price history is linked to one Product
  product   Product  @relation(fields: [productId], references: [id]) 

  // Unique price history per product per timestamp
  @@unique([productId, createdAt]) 
}

model Raffle {
  // Unique ID for the raffle
  id          Int           @id @default(autoincrement()) 
  // Title of the raffle
  title       String        
  // Detailed description
  description String        
  // Type of the raffle
  type        RaffleType    
  // Current status of the raffle
  status      RaffleStatus  
  // Optional link for online entries
  entryUrl String? 
  // Timestamp for when the raffle was created
  createdAt   DateTime      @default(now()) 
  // Timestamp for when the raffle ends
  endsAt      DateTime      
  // Product associated with the raffle
  productId   Int           
  // Many-to-One: A raffle is linked to one Product
  product     Product       @relation(fields: [productId], references: [id]) 
  // One-to-Many: A raffle can have multiple entries
  entries     RaffleEntry[] 
}

model RaffleEntry {
  // Unique ID for entry
  id        Int      @id @default(autoincrement()) 
  // User ID of the entrant
  userId    Int      
  // Raffle ID entered
  raffleId  Int      
  // Timestamp of entry creation
  createdAt DateTime @default(now()) 
  // Result of the entry (WON, LOST, PENDING)
  result    RaffleResult 
  // Many-to-One: Raffle entry is linked to one User
  user      User     @relation(fields: [userId], references: [id]) 
  // Many-to-One: Raffle entry is linked to one Raffle
  raffle    Raffle   @relation(fields: [raffleId], references: [id]) 

  // Ensure a user can enter a raffle only once
  @@unique([userId, raffleId]) 
}

model Media {
  // Unique ID for media entry
  id        Int      @id @default(autoincrement()) 
  // Product ID that this media belongs to
  productId Int      
  // URL of the media file (e.g., image, video)
  url       String   
  // Type of media (image, video, etc.)
  type      String   
  // Timestamp of when the media was added
  createdAt DateTime @default(now()) 
  // Many-to-One: Each media entry is linked to one Product
  product   Product  @relation(fields: [productId], references: [id]) 
}

model Comment {
  // Unique ID for comment (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // Product ID the comment is associated with (Foreign Key)
  productId Int      
  // User ID of the commenter (Foreign Key)
  userId    Int      
  // Optional Thread ID the comment is associated with (Foreign Key)
  threadId  Int?     
  // Content of the comment
  content   String   
  // Timestamp of when the comment was created
  createdAt DateTime @default(now()) 
  // Many-to-One: Each comment is linked to one User
  user      User     @relation(fields: [userId], references: [id]) 
  // Many-to-One: Each comment is linked to one Product
  product   Product  @relation(fields: [productId], references: [id]) 
  // Many-to-One: Optional link to a discussion thread
  thread    Thread?  @relation(fields: [threadId], references: [id]) 

  // Ensure a user can only comment once per Product
  @@unique([userId, productId]) 
}

model Report {
  // Unique ID for report (Primary Key)
  id             Int      @id @default(autoincrement()) 
  // Product ID that is being reported (Foreign Key)
  productId      Int      
  // User ID who is reporting (Foreign Key)
  userId         Int      
  // Reason for the report
  reason         String   
  // Timestamp of when the report was filed
  createdAt      DateTime @default(now()) 
  // User ID that has been blocked (optional, Foreign Key)
  blockedUserId  Int?     
  // Many-to-One: Each report is linked to one User
  user           User     @relation(fields: [userId], references: [id]) 
  // Many-to-One: Each report is linked to one Product
  product        Product  @relation(fields: [productId], references: [id]) 

  // Ensure a user can report the same Product only once
  @@unique([userId, productId]) 
}

model Message {
  // Unique ID for message (Primary Key)
  id         Int               @id @default(autoincrement()) 
  // User ID of the sender (Foreign Key)
  senderId   Int               
  // User ID of the receiver (Foreign Key)
  receiverId Int               
  // Content of the message
  content    String            
  // Timestamp of when the message was sent
  createdAt  DateTime          @default(now()) 
  // One-to-Many: A Message can have multiple MessageReactions
  reactions  MessageReaction[]  
  // Many-to-One: Each Message has one Sender
  sender     User              @relation("Sender", fields: [senderId], references: [id]) 
  // Many-to-One: Each Message has one Receiver
  receiver   User              @relation("Receiver", fields: [receiverId], references: [id]) 
}

model MessageReaction {
  // Unique ID for reaction (Primary Key)
  id        Int          @id @default(autoincrement()) 
  // Message ID that is being reacted to (Foreign Key)
  messageId Int          
  // User ID who reacted (Foreign Key)
  userId    Int          
  // Type of reaction (like, love, etc.)
  type      ReactionType 
  // Timestamp of when the reaction was made
  createdAt DateTime     @default(now()) 
  // Many-to-One: Each MessageReaction is linked to one Message
  message   Message      @relation(fields: [messageId], references: [id]) 
  // Many-to-One: Each MessageReaction is linked to one User
  user      User         @relation(fields: [userId], references: [id]) 

  // Ensure a User can react to a Message only once
  @@unique([userId, messageId]) 
}

model SearchHistory {
  // Unique ID for search history entry (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // Foreign key to User (ID of the user who made the search, Foreign Key)
  userId    Int      
  // Search query
  query     String   
  // Timestamp of when the search was made
  createdAt DateTime @default(now()) 
  // Many-to-One: Each SearchHistory entry links to one User
  user      User     @relation(fields: [userId], references: [id]) 
}

model SavedSearch {
  // Unique ID for saved search (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // Foreign key to User (ID of the user who saved the search, Foreign Key)
  userId    Int      
  // Search query
  query     String   
  // Timestamp of when the search was saved
  createdAt DateTime @default(now()) 
  // Many-to-One: Each SavedSearch links to one User
  user      User     @relation(fields: [userId], references: [id]) 
}

model Wishlist {
  // Unique ID for wishlist entry (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // Foreign key to User (ID of the user who owns the wishlist entry, Foreign Key)
  userId    Int      
  // Foreign key to Product (ID of the product associated with this wishlist entry, Foreign Key)
  productId Int      
  // Timestamp of when the entry was created
  createdAt DateTime @default(now()) 
  // Many-to-One: Each Wishlist entry links to one User
  user      User     @relation(fields: [userId], references: [id]) 
  // Many-to-One: Each Wishlist entry links to one Product
  product   Product  @relation(fields: [productId], references: [id]) 

  // Ensure a user can have only one wishlist entry per product
  @@unique([userId, productId]) 
}

model Thread {
  // Unique ID for discussion thread (Primary Key)
  id        Int       @id @default(autoincrement()) 
  // Foreign key to User (ID of the user who created the thread, Foreign Key)
  userId    Int       
  // Title of the thread
  title     String    
  // Timestamp of when the thread was created
  createdAt DateTime  @default(now()) 
  // One-to-Many: A Thread can have multiple Comments
  comments  Comment[] 
  // Many-to-One: Each Thread links to one User
  user      User      @relation(fields: [userId], references: [id]) 
}

model Post {
  // Unique ID for the post (Primary Key)
  id                Int              @id @default(autoincrement()) 
  // Content of the post
  content           String           
  // Timestamp of when the post was created
  createdAt        DateTime         @default(now()) 
  // Timestamp for when the post was last updated
  updatedAt        DateTime         @updatedAt 
  // User ID of the post's author (Foreign Key)
  userId           Int              
  // One-to-Many: Metrics related to post engagement
  engagementMetrics EngagementMetric[] 
  // One-to-Many: A Post can have multiple Reactions
  reactions        PostReaction[]    @relation("PostReactions") 
  // Many-to-One: Each Post links to one User
  user             User              @relation(fields: [userId], references: [id]) 
}

model PostReaction {
  // Unique ID for reaction (Primary Key)
  id        Int     @id @default(autoincrement()) 
  // User ID who reacted (Foreign Key)
  userId    Int     
  // Post ID that is being reacted to (Foreign Key)
  postId    Int     
  // Type of reaction (assuming ReactionType enum is defined)
  type      ReactionType 
  // Timestamp of when the reaction was made
  createdAt DateTime @default(now()) 
  // Many-to-One: A PostReaction links to one User
  user      User   @relation("UserPostReactions", fields: [userId], references: [id]) 
  // Many-to-One: A PostReaction links to one Post
  post      Post   @relation("PostReactions", fields: [postId], references: [id]) 

  // Ensure a user can react to a post only once
  @@unique([userId, postId]) 
}

model Poll {
  // Unique ID for poll (Primary Key)
  id        Int          @id @default(autoincrement()) 
  // User ID who created the poll (Foreign Key)
  userId    Int          
  // Poll question
  question  String       
  // Timestamp of when the poll was created
  createdAt DateTime     @default(now()) 
  // One-to-Many: A Poll can have multiple options
  options   PollOption[]  
  // One-to-Many: A Poll can receive multiple votes
  votes     PollVote[]    
  // Many-to-One: A Poll links to one User
  user      User         @relation(fields: [userId], references: [id]) 

  // Ensure a user can create only one poll with a specific question
  @@unique([userId, question]) 
}

model PollOption {
  // Unique ID for option (Primary Key)
  id        Int        @id @default(autoincrement()) 
  // Foreign key to the Poll this option belongs to
  pollId    Int        
  // Option content
  content   String     
  // Timestamp of when the option was created
  createdAt DateTime   @default(now()) 
  // One-to-Many: One option can receive multiple votes
  votes     PollVote[] 
  // Many-to-One: An option links to one Poll
  poll      Poll       @relation(fields: [pollId], references: [id]) 

  // Ensure option content is unique within the same poll
  @@unique([pollId, content]) 
}

model PollVote {
  // Unique ID for vote (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // User ID who voted (Foreign Key)
  userId    Int      
  // Poll ID that is being voted on (Foreign Key)
  pollId    Int      
  // Selected option ID (Foreign Key)
  optionId  Int      
  // Timestamp of when the vote was made
  createdAt DateTime @default(now()) 
  // Many-to-One: A vote is linked to one User
  user      User       @relation(fields: [userId], references: [id]) 
  // Many-to-One: A vote is linked to one Poll
  poll      Poll       @relation(fields: [pollId], references: [id]) 
  // Many-to-One: A vote is linked to one PollOption
  option    PollOption  @relation(fields: [optionId], references: [id]) 

  // Ensure a user can vote in a poll only once
  @@unique([userId, pollId]) 
}

model SupportTicket {
  // Unique ID for support ticket (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // User ID who created the ticket (Foreign Key)
  userId    Int      
  // Subject of the support request
  subject   String    
  // Detailed message content
  message   String    
  // Status of the ticket (e.g., open, closed)
  status    TicketStatus    
  // Timestamp of when the ticket was created
  createdAt DateTime @default(now()) 
  // Many-to-One: Many SupportTickets can be created by One User
  user      User     @relation(fields: [userId], references: [id]) 

  // Ensure a user can create only one ticket with a specific subject
  @@unique([userId, subject]) 
}

model Badge {
  // Unique ID for badge (Primary Key)
  id          Int         @id @default(autoincrement()) 
  // Name of the badge
  name        String      
  // Description of the badge
  description String      
  // Timestamp of when the badge was created
  createdAt   DateTime    @default(now()) 
  // One-to-Many: One Badge can be earned by multiple UserBadges
  userBadges  UserBadge[] 

  // Ensure each badge name is unique
  @@unique(name) 
}

model Review {
  // Unique ID for the review (Primary Key)
  id          Int      @id @default(autoincrement()) 
  // Foreign key to the Product being reviewed
  productId   Int      
  // Foreign key to the User who wrote the review
  userId      Int      
  // Percentage score provided by the user (0 to 100)
  percentage   Float    // Feedback score from 0% to 100%
  // Review content
  content     String   
  // Timestamp of when the review was created
  createdAt   DateTime @default(now()) 
  // Timestamp of when the review was last updated
  updatedAt   DateTime @updatedAt 
  // Array of image URLs uploaded with the review
  imageUrls   String[] 

  // Many Reviews can belong to one Product
  product     Product  @relation(fields: [productId], references: [id]) 
  // Many Reviews can belong to one User
  user        User     @relation(fields: [userId], references: [id]) 

  // Ensure a user can only review a product once
  @@unique([productId, userId]) 
}


// model Review {
//   // Unique ID for the review (Primary Key)
//   id          Int      @id @default(autoincrement()) 
//   // Foreign key to the Product being reviewed
//   productId   Int      
//   // Foreign key to the User who wrote the review
//   userId      Int      
//   // Rating given by the user (e.g., 1 to 5 stars)
//   rating      Int      
//   // Review content
//   content     String   
//   // Timestamp of when the review was created
//   createdAt   DateTime @default(now()) 
//   // Timestamp of when the review was last updated
//   updatedAt   DateTime @updatedAt 
//   // Array of image URLs uploaded with the review
//   imageUrls   String[] 

//   // Many Reviews can belong to one Product
//   product     Product  @relation(fields: [productId], references: [id]) 
//   // Many Reviews can belong to one User
//   user        User     @relation(fields: [userId], references: [id]) 

//   // Ensure a user can only review a product once
//   @@unique([productId, userId]) 
// }



model SearchFilter {
  // Unique ID for search filter (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // User ID who created the filter (Foreign Key)
  userId    Int      
  // JSON object containing filter criteria
  filters   Json     
  // Timestamp of when the filter was created
  createdAt DateTime @default(now()) 
  // Timestamp of when the filter was last updated
  updatedAt DateTime @updatedAt 
  // Many SearchFilters can belong to one User
  user      User     @relation(fields: [userId], references: [id]) 
}

model ProductRating {
  // Unique ID for product rating (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // Foreign key to the Product that is being rated
  productId Int      
  // Foreign key to the User who gave the rating
  userId    Int      
  // Rating value (e.g., 1 to 5 stars)
  rating    Int      
  // Timestamp of when the rating was created
  createdAt DateTime @default(now()) 
  // Many ProductRatings can belong to one Product
  product   Product  @relation(fields: [productId], references: [id]) 
  // Many ProductRatings can belong to one User
  user      User     @relation(fields: [userId], references: [id]) 

  // Ensure a user can only rate a product once
  @@unique([productId, userId]) 
}

model Language {
  // Unique ID for the language (Primary Key)
  id          Int      @id @default(autoincrement()) 
  // Language code (e.g., 'en', 'fr', 'es')
  code        String   
  // Full name of the language
  name        String   
  // Foreign key for the user
  userId      Int     
  // One Language can be preferred by many Users
  user        User     @relation(fields: [userId], references: [id]) 
}

model UserPreference {
  // Unique ID for the preference entry (Primary Key)
  id          Int      @id @default(autoincrement()) 
  // User ID for preference (Foreign Key)
  userId      Int      
  // JSON object to store various user preferences
  preferences Json      
  // Timestamp of when the preference was created
  createdAt   DateTime @default(now()) 
  // Timestamp of when the preference was last updated
  updatedAt   DateTime @updatedAt 
  // Many UserPreferences can belong to one User
  user        User     @relation(fields: [userId], references: [id]) 

  // Ensure a user can only have one set of preferences
  @@unique(userId) 
}

model Tag {
  // Unique ID for the tag (Primary Key)
  id        Int        @id @default(autoincrement()) 
  // Name of the tag
  name      String     
  // One Tag can be associated with many ProductTags
  products  ProductTag[] @relation("ProductTags") 

  // Ensure each tag name is unique
  @@unique(name) 
}

model ProductTag {
  // Unique ID for the product-tag relationship (Primary Key)
  id        Int      @id @default(autoincrement()) 
  // Foreign key to Product (Foreign Key)
  productId Int      
  // Foreign key to Tag (Foreign Key)
  tagId     Int      
  // Many ProductTags can belong to one Product
  product   Product  @relation(fields: [productId], references: [id]) 
  // Many ProductTags can belong to one Tag
  tag       Tag      @relation(fields: [tagId], references: [id], name: "ProductTags") 

  // Ensure a product can only have one instance of a specific tag
  @@unique([productId, tagId]) 
}

model EngagementMetric {
  // Unique ID for the engagement metric entry (Primary Key)
  id          Int      @id @default(autoincrement()) 
  // User ID associated with the engagement (Foreign Key)
  userId      Int      
  // Nullable: Foreign key to Product (if applicable)
  productId   Int?     
  // Nullable: Foreign key to Post (if applicable)
  postId      Int?     
  // Type of action (e.g., "view", "like", etc.)
  actionType  String    
  // Timestamp when the action was recorded
  createdAt   DateTime @default(now()) 
  // Many EngagementMetrics can belong to one User
  user        User     @relation(fields: [userId], references: [id]) 
  // Optional: Many EngagementMetrics can be associated with one Product
  product     Product? @relation(fields: [productId], references: [id]) 
  // Optional: Many EngagementMetrics can be associated with one Post
  post        Post?    @relation(fields: [postId], references: [id]) 

  // Ensure a user can perform the same action on a product only once
  @@unique([userId, productId, actionType]) 
  // Ensure a user can perform the same action on a post only once
  @@unique([userId, postId, actionType]) 
}

model ModerationReport {
  // Unique ID for each report (Primary Key)
  id            Int      @id @default(autoincrement()) 
  // ID of the user who reported the issue (Foreign Key)
  reportedById  Int      
  // ID of the target (user, product, etc.) being reported
  targetId      Int      
  // Description of the reason for the report
  reason        String    
  // Current status of the report (e.g., "pending", "resolved")
  status        String    
  // Timestamp when the report was created
  createdAt     DateTime @default(now()) 
  // Timestamp when the report was last updated
  updatedAt     DateTime @updatedAt 
  // Many ModerationReports can be made by one User
  reportedBy    User     @relation(fields: [reportedById], references: [id]) 

  // Ensure a user can only report a specific target once
  @@unique([reportedById, targetId]) 
}

model ProductVariant {
  // Unique ID for each product variant (Primary Key)
  id        Int           @id @default(autoincrement()) 
  // Foreign key linking to the Product (Foreign Key)
  productId Int           
  // Size of the product variant (e.g., "M", "L")
  size      String        
  // Color of the product variant (e.g., "Red", "Blue")
  color     String        
  // One ProductVariant can have many Inventories
  inventories Inventory[]  @relation("VariantInventories") 
  // Many ProductVariants can belong to one Product
  product   Product       @relation(fields: [productId], references: [id]) 

  // Ensure each combination of productId, size, and color is unique
  @@unique([productId, size, color]) 
}

model Inventory {
  // Unique ID for each inventory entry (Primary Key)
  id        Int           @id @default(autoincrement()) 
  // Foreign key linking to the ProductVariant (Foreign Key)
  variantId Int           
  // Number of items in stock for this variant
  quantity  Int           
  // Timestamp when the inventory entry was created
  createdAt DateTime      @default(now()) 
  // Timestamp when the inventory entry was last updated
  updatedAt DateTime      @updatedAt 
  // Many Inventory entries can belong to one ProductVariant
  variant   ProductVariant @relation("VariantInventories", fields: [variantId], references: [id]) 

  // Ensure each variant has a unique inventory entry
  @@unique([variantId]) 
}

model Achievement {
  // Unique ID for the achievement (Primary Key)
  id          Int         @id @default(autoincrement()) 
  // Name of the achievement
  name        String      
  // Description of what the achievement entails
  description String      
  // JSON object defining the criteria for earning the achievement
  criteria    Json        
  // Timestamp of when the achievement was created
  createdAt   DateTime    @default(now()) 
  // One Achievement can be earned by many UserAchievements
  userAchievements UserAchievement[] 

  // Ensure each achievement name is unique
  @@unique(name) 
}

model UserAchievement {
  // Unique ID for the user achievement entry (Primary Key)
  id            Int         @id @default(autoincrement()) 
  // ID of the user who earned the achievement (Foreign Key)
  userId        Int         
  // ID of the achievement that this entry relates to (Foreign Key)
  achievementId Int         
  // Timestamp of when the achievement was earned
  createdAt     DateTime    @default(now()) 
  // Many UserAchievements can belong to one User
  user          User        @relation(fields: [userId], references: [id]) 
  // Many UserAchievements can relate to one Achievement
  achievement   Achievement @relation(fields: [achievementId], references: [id]) 

  // Ensure a user can only earn the same achievement once
  @@unique([userId, achievementId]) 
}

model Leaderboard {
  // Unique ID for each leaderboard entry (Primary Key)
  id           Int        @id @default(autoincrement()) 
  // ID of the user participating in the leaderboard (Foreign Key)
  userId       Int        
  // Score based on various metrics (e.g., sales, reviews, etc.)
  score        Int        
  // Timestamp when the entry was created
  createdAt    DateTime   @default(now()) 
  // Timestamp when the entry was last updated
  updatedAt    DateTime   @updatedAt 
  // Many Leaderboard entries can belong to one User
  user         User       @relation(fields: [userId], references: [id]) 

  // Ensure a user can only appear once in the leaderboard
  @@unique(userId) 
}

model Bundle {
  // Unique ID for each bundle (Primary Key)
  id          Int            @id @default(autoincrement()) 
  // The name of the bundle
  name        String         
  // Optional description of the bundle
  description String?        
  // Total price of the bundle
  price       Float          
  // Timestamp when the bundle was created
  createdAt   DateTime       @default(now()) 
  // Timestamp when the bundle was last updated
  updatedAt   DateTime       @updatedAt 
  // One Bundle can include many ProductBundles
  products    ProductBundle[] 

  // Ensure each bundle name is unique
  @@unique(name) 
}

model ProductBundle {
  // Unique ID for each product-bundle relationship (Primary Key)
  id        Int     @id @default(autoincrement()) 
  // ID of the associated bundle (Foreign Key)
  bundleId Int     
  // ID of the associated product (Foreign Key)
  productId Int    
  // Number of this product included in the bundle
  quantity Int     
  // Many ProductBundles can belong to one Bundle
  bundle   Bundle  @relation(fields: [bundleId], references: [id]) 
  // Many ProductBundles can belong to one Product
  product  Product @relation(fields: [productId], references: [id]) 
}